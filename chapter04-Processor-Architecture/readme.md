
<!-- TOC -->

- [第四章 处理器体系结构](#第四章-处理器体系结构)
    - [1. Y86指令集](#1-y86指令集)
    - [2. 硬件控制语言HCL](#2-硬件控制语言hcl)
    - [3. Y86的顺序实现](#3-y86的顺序实现)
    - [4. 流水线通用原理](#4-流水线通用原理)

<!-- /TOC -->


# 第四章 处理器体系结构

## 1. Y86指令集

处理器状态有8个通用寄存器: %eax, %ecx, %edx, %ebx, %esi, %edi, %esp, %ebp

IA32体系结构:
- 8个GPR（0~7），一个EFLAGs，PC为EIP
- 可寻址空间4GB（编号为0~0xFFFFFFFF）
- 指令格式变长，操作码变长，指令由若干字段（OP、Mod、SIB等）组成

IA-32的标志寄存器EFlags
- 6个条件标志: OF, ZF, SF, CF, AF：辅助进位标志（BCD码运算时才有意义）,PF：奇偶标志
- 3个控制标志
  - DF（Direction Flag）：方向标志（自动变址方向是增还是减）
  - IF（Interrupt Flag）：中断允许标志 （仅对外部可屏蔽中断有用）
  - TF（Trap Flag）：陷阱标志（是否是单步跟踪状态）

存储器操作数的寻址方式与微处理器的工作模式有关
- 实地址模式
  - 为与8086/8088兼容而设，加电或复位时
  - 寻址空间为1MB，20位地址：(CS)<<4+(IP)
- 保护模式
  - 加电后进入，采用虚拟存储管理，多任务情况下隔离、保护
  - 80286以上微处理器的工作模式
  - 寻址空间为232B，32位线性地址分段（段基址+段内偏移量）

机器指令格式:
- 指令前缀prefix: 大小为1字节，用来辅助说明指令的具体功能，可选项
- 操作码Opcode: 1/2字节, 与机器模式一起确定寄存器编码(AL/AX/EAX)
- 寻址方式ModR/M: 0/1字节, Mod(2bit) + Reg/Op(3bit) + R/M(3bit), 需要和机器模式一起确定寄存器模式
- SIB(Scale-Index-Base): 0/1字节, SS(2bit) + Index Reg(3bit) + Base Reg(3bit)
- 位移displacement: 1/2/4字节, 寻址方式中可能存在位移项, 例如PC相对寻址
- 立即数Immediate: 1/2/4字节

```
例如指令:
leal (%edx,%eax,1), %eax
8d 04 02
1000 1101 0000 0100 0000 0010
对应的解释
1000 1101 00 000(%eax) 100 00(缩放因子1) 000(%eax) 010(%edx)

IA32对寄存器使用3bit编码, 因此可以将入栈出栈操作指令放在一个字节里, 剩下5个bit表明指令类型
IA32中可以将常数值编码成1/2/4个字节, 而不是固定长度
IA32中寄存器字段的位置不是固定的, 可是根据Opcode而定
```


CISC和RISC
- CISC指令长度可变, IA32指令长度为1-15字节, 而RISC指令编码为4个字节, 固定长度
- 同时RISC只能对寄存器操作数进行算术和逻辑操作, 而对存储器引用只能进行load和store指令, 称为load/store体系结构
- 没有条件码, 而是需要明确的测试指令, 而不是IA32中作为指令执行的副产品设置一些特殊位
- RISC中是栈密集的过程链接(IA32), 而CISC中是寄存器密集的过程链接, 通常有较多的寄存器(mips有32个通用寄存器)


pushl %esp
- pushl指令会将栈帧减4, 然后将寄存器的值写入到栈顶
- 执行pushl %esp的行为是不确定的, 可能是压入的是旧值, 或者是减4之后的值(286开始压入的是旧值)
- popl %esp之后, %esp的值时栈顶的值, 等价于 movl (%esp), %esp


## 2. 硬件控制语言HCL

组合电路
- 多路复用器
- 算术逻辑单元(ALU): 是一个组合电路, 输入有A,B和控制信号S三个输入, 根据控制信号对输入执行不同的算术或者逻辑操作

时序电路:
- 时钟寄存器: 可以存储单个位或者单个字
- 随机访问存储器: 可以通过地址线选择该读或者写那个字, 其中数据传输通过数据线传输
- 数据存储器: 有地址输入, 写的数据输入, 读的数据输出, 以及一个时钟输入(控制信号), 还有错误输出

## 3. Y86的顺序实现

SEQ处理器:
1. 取指Fetch: 从存储器读取指令字节
2. 译码Decode:根据读取的指令分析opcode, 操作数类型
3. 执行Execute: ALU执行指令操作
4. 访存Memory: 可以将数据写入存储器或者从存储器读入数据
5. 写回Write back: 可以将结果写入到寄存器文件
6. 更新PC(PC update): 将PC设置为下一条执行指令的地址


## 4. 流水线通用原理

**流水线冒险hazard**

指令序列在流水线中执行时可能遇到问题, 使得流水线无法正确按时执行后续指令, 从而引起流水线阻塞或者停顿
- 结构冒险: structural hazard, 同一部件被不同的指令使用, 例如第一条指令的Memory截断取数据的同时第三条指令在取指令Fetch截断, 它们使用相同的寄存器, 因此发生结构冒险
  - 将指令存储器和数据存储器分开, 每一个截断只能使用特定的寄存器
- 数据冒险: data hazard/dependency, 后面的指令需要使用前面指令的结果,
  - 加上nop空指令方法
  - 采用数据转发方式, 在流水线中采用旁路将结果值直接传递后续指令的ALU输入端, 而不必等待前面的指令将结果写回到寄存器
- 控制冒险: 当指令执行顺序改变时, 流水线中的指令会阻塞, 各种转移类指令和异常中断都会引发控制冒险


**高级流水线实现技术**
- 超流水线 super-pipelining: 增加流水线级数
- 多发射流水线: 同时启动多条指令(整数运算, 浮点运算, 存储器访问等)独立运行来提高指令并行性